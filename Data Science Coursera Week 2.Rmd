---
title: "Data Science Coursera Week 2"
author: "Amina"
date: "11/16/2016"
output: html_document
---
 *************  
 WEEK 2 is ABOUT:
 1. FUNCTIONS
 2. CONTROL STRUCTURES 
 3. SCOPING
 4. DATES AND TIME
**************

1. FUNCTIONS

 What is a function?
 
- A function is a piece of code written to carry out a specified task.
 
- If you have to repeat the same few lines of code more than once, then you really need to write a function. Functions are a fundamental building block of R. You use them all the time in R and it's not that much harder to string functions together (or write entirely new ones from scratch) to do more.

- R functions are objects just like anything else.
- By default, R function arguments are lazy - they're only evaluated if they're actually used:
- Every call on a R object is almost always a function call.
 
 In R, you define a function with the construct:
 function ( arglist )  {body}
 
 
```{r
# define a simple function
myFirstFun<-function(n)
{
  n*n  #  compute the square of integer n
}
# define a value
k<-10
# call the function with that value
m<-myFirstFun(k)```
```{Define a simple function}
myfirstfun<- function(n)
{
   n*n
}
m
```
A few comments are necessary to illustrate its working:

- We first define the function as a variable, myFirstFun, using the keyword function, which also receives n as argument (no type specification). The latter will exist within the function. We used an integer, but 'n' could also be a vector or a matrix or a string: R handles all this nicely for us
- In our snippet, when we call the function, we assign it to a variable m. This is not necessary per se, because R will always print the last evaluation done, but we do this for clarity and perhaps because we may want to re-use the result later [if we don't, R will have forgotten this evaluation by the time the next command is run]
- When we call the function, we may use an arbitrary variable, here k, to which we assign an integer value. We do this to illustrate that the variable does not need to have the same name (and the same type, we'll see this later) because it is a different object, so
- We could have used the same name, n; however note that this n is not the same we used within the function body.

```{functions}
> args(lm)
function (formula, data, subset, weights, na.action,
method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...)
```

2. CONTROL STRUCTURES
** Control Structures **
These allow you to control the flow of execution of a script typically inside of a function. Common ones include:

if, else
for
while
repeat
break
next
return

We don't use these while working with R interactively but rather inside functions.

IF
```{IF}
if (condition) {
    # do something
} else {
    # do something else
}
```

Example:
```{example 1}
x <- 1:15
if (sample(x, 1) <= 10) {
    print("x is less than 10")
} else {
    print("x is greater than 10")
}
```

Vectorization with ifelse

```{ifelse}
ifelse(x <= 10, "x less than 10", "x greater than 10")
```

Other valid ways of writing if/else

```{other ways}
if (sample(x, 1) < 10) {
    y <- 5
} else {
    y <- 0
}
```

```{or}
y <- if (sample(x, 1) < 10) {
    5
} else {
    0
}
```

FOR

A for loop works on an iterable variable and assigns successive values till the end of a sequence.

```{example using for}
for (i in 1:10) {
    print(i)
}
```


```{another example using for}
x <- c("apples", "oranges", "bananas", "strawberries")

for (i in x) {
    print(x[i])
}

for (i in 1:4) {
    print(x[i])
}

for (i in seq(x)) {
    print(x[i])
}

for (i in 1:4) print(x[i])
```

These three loops have the same behavior.

```{from slides_1}
x <- c("a", "b", "c", "d") for(i in 1:4) {
print(x[i])
}
for(i in seq_along(x)) { print(x[i])
}
for(letter in x) { print(letter)
}
for(i in 1:4) print(x[i])
```



NESTED LOOPS

```{nested loops}
m <- matrix(1:10, 2)
for (i in seq(nrow(m))) {
    for (j in seq(ncol(m))) {
        print(m[i, j])
    }
}
```

```{example from course slides}
x <- matrix(1:6, 2, 3)
for(i in seq_len(nrow(x))) {
for(j in seq_len(ncol(x))) {
} }
```


WHILE

```{while}
i <- 1
while (i < 10) {
    print(i)
    i <- i + 1
}
```
 !!!  Be sure there is a way to exit out of a while loop. !!!

REPEAT AND BREAK

```{repeat and break}
repeat {
    # simulations; generate some value have an expectation if within some range,
    # then exit the loop
    if ((value - expectation) <= threshold) {
        break
    }
}
```

NEXT

```{next}
for (i in 1:20) {
    if (i%%2 == 1) {
        next
    } else {
        print(i)
    }
}
```
- reminder "%%" indicates modular division - i.e. integer-divide x by y and return the remainder. 
- reminder "==" is always used for equality testing.

REPEAT

Repeat initiates an infinite loop; these are not commonly used in statistical applications but they do have their uses. The only way to exit a repeat loop is to call break.
```{from slides_2}
x0<-1 tol <- 1e-8
repeat {
x1 <- computeEstimate()
if(abs(x1 - x0) < tol) { break
}else{ x0<-x1
} }
```

The loop in the previous slide is a bit dangerous because there’s no guarantee it will stop. Better to set a hard limit on the number of iterations (e.g. using a for loop) and then report whether convergence was achieved or not.

NEXT, RETURN
next is used to skip an iteration of a loop
return signals that a function should exit and return a given value

```{from slides}
for(i in 1:100) { if(i <= 20) {
## Skip the first 20 iterations
next
## Do something here
}
```

3. SCOPING

How does R know which value to assign to which symbol?
When R tries to bind a value to a symbol, it searches through a series of environments to find the appropriate value. When you are working on the command line and need to retrieve the value of an R object, the order is roughly
1. Search the global environment for a symbol name matching the one requested. 2. Search the namespaces of each of the packages on the search list
The search list can be found by using the search function.

```{type}
serach()
```

- The global environment or the user’s workspace is always the first element of the search list and the base package is always the last.

· The order of the packages on the search list matters!

· User’s can configure which packages get loaded on startup so you cannot assume that there will
be a set list of packages available.

· When a user loads a package with library the namespace of that package gets put in position 2 of the search list (by default) and everything else gets shifted down the list.

· Note that R has separate namespaces for functions and non-functions so it’s possible to have an object named c and a function named c.

FREE VARIABLE: Free variables are not formal arguments and are not local variables (assigned insided the function body).

Example:

```{z is a free variable}
f <- function(x, y) { x^2+y/z
}
```

LEXICAL VERSUS DYNAMIC SCOPING

```{from slides_3}
y<-10
f <- function(x) { y<-2
y^2 + g(x)
}
g <- function(x) { x*y
}
```

- With lexical scoping the value of y in the function g is looked up in the environment in which the function was defined, in this case the global environment, so the value of y is 10.

- With dynamic scoping, the value of y is looked up in the environment from which the function was called (sometimes referred to as the calling environment).

- In R the calling environment is known as the parentframe. 

- So the value of y would be 2.


APPLICATION OF SCOPING RULES: OPTMISATION

Why is any of this information useful?

· Optimization routines in R like optim, nlm, and optimize require you to pass a function whose argument is a vector of parameters (e.g. a log-likelihood)

· However, an object function might depend on a host of other things besides its parameters (like data)

· When writing software which does optimization, it may be desirable to allow the user to hold certain parameters fixed

4. DATES AND TIMES

Dates and times have special classes in R that allow for numerical and statistical calculations

· Dates use the Date class

· Times use the POSIXct and POSIXlt class

· Character strings can be coerced to Date/Time classes using the strptime function or the as.Date, as.POSIXlt, or as.POSIXct